/*! @alxcube/lens 2.0.1
Â© 2020-2023 Alexander Alexandrov <alxcube@gmail.com>
License: Apache-2.0 */
class et {
  constructor(t) {
    if (this.neighborsCount = t, ![2, 3, 4].includes(this.neighborsCount))
      throw new RangeError(`Neighbors count must be 2, 3 or 4. ${this.neighborsCount} given`);
  }
  interpolate(t, e, i) {
    let s, o;
    const a = this.neighborsCount;
    switch (a) {
      case 2:
        s = Math.floor(e), o = Math.floor(i);
        break;
      case 3:
        s = Math.floor(e + 0.5) - 1, o = Math.floor(i + 0.5) - 1;
        break;
      case 4:
        s = Math.floor(e) - 1, o = Math.floor(i) - 1;
    }
    const n = s + a, l = o + a, h = [0, 0, 0, 0];
    for (let d = o; d < l; d++)
      for (let c = s; c < n; c++) {
        const g = t.getPixelColor(c, d);
        h[0] += g[0], h[1] += g[1], h[2] += g[2], h[3] += g[3];
      }
    const u = 1 / (a * a);
    return [Math.round(h[0] * u), Math.round(h[1] * u), Math.round(h[2] * u), Math.round(h[3] * u)];
  }
}
class At {
  interpolate(t) {
    return t.getBackgroundColor();
  }
}
class Mt {
  interpolate(t, e, i) {
    return t.getPixelColor(Math.floor(e), Math.floor(i));
  }
}
var w = ((r) => (r[r.AVERAGE = 1] = "AVERAGE", r[r.AVERAGE_9 = 2] = "AVERAGE_9", r[r.AVERAGE_16 = 3] = "AVERAGE_16", r[r.BACKGROUND = 4] = "BACKGROUND", r[r.INTEGER = 8] = "INTEGER", r))(w || {});
class Et {
  create(t) {
    switch (t) {
      case w.AVERAGE:
        return new et(2);
      case w.AVERAGE_9:
        return new et(3);
      case w.AVERAGE_16:
        return new et(4);
      case w.BACKGROUND:
        return new At();
      case w.INTEGER:
        return new Mt();
    }
    throw new TypeError(`Unknown interpolation method: ${t}`);
  }
}
class Ft {
  constructor(t, e) {
    this.colorResamplerFactoriesPool = t, this.resampleFilterResolver = e;
  }
  resolve(t, e, i = {}) {
    const { preferredResampler: s, filter: o, matteColor: a, interpolationMethod: n, virtualPixelMethod: l } = i, h = this.getColorResamplerFactory(s, o);
    let u;
    return o && h.supportsEwa && (u = this.resampleFilterResolver.resolve(o, i)), h.create(t, e, { resampleFilter: u, matteColor: a, interpolationMethod: n, virtualPixelMethod: l });
  }
  getColorResamplerFactory(t, e) {
    let i;
    if (t !== void 0) {
      const o = this.colorResamplerFactoriesPool.get(t);
      if (o.requiresResampleFilter && !e)
        throw new TypeError(`Preferred color resampler "${t}" requires ResampleFilter`);
      return o;
    }
    if (e !== void 0 && (i = this.colorResamplerFactoriesPool.items().find((o) => o.supportsEwa), i))
      return i;
    const s = this.colorResamplerFactoriesPool.items().filter((o) => !o.requiresResampleFilter);
    if (!s.length)
      throw new Error("No color resampler factories in pool.");
    return s[0];
  }
}
function Vt(r) {
  return typeof r == "object" && r !== null && typeof r.getResampledColor == "function" && typeof r.setScaling == "function" && typeof r.getScaling == "function";
}
class x {
  constructor(t) {
    this.decorated = t, this.width = this.decorated.width, this.height = this.decorated.height, { x1: this.offsetX, y1: this.offsetY } = this.decorated.getViewport();
  }
  getPixelColor(t, e) {
    return t = Math.floor(t - this.offsetX), e = Math.floor(e - this.offsetY), t >= 0 && t < this.width && e >= 0 && e < this.height ? this.decorated.getPixelColor(t, e) : this.getVirtualPixelColor(t, e);
  }
  setPixelColor(t, e, i) {
    t = Math.floor(t - this.offsetX), e = Math.floor(e - this.offsetY), t >= 0 && t < this.width && e >= 0 && e < this.height && this.decorated.setPixelColor(t, e, i);
  }
  getQuantumRange() {
    return this.decorated.getQuantumRange();
  }
  getViewport() {
    return this.decorated.getViewport();
  }
  getAverageColor() {
    return this.decorated.getAverageColor();
  }
  getBackgroundColor() {
    return this.decorated.getBackgroundColor();
  }
  getDecorated() {
    return this.decorated;
  }
}
class It extends x {
  getVirtualPixelColor() {
    return this.decorated.getBackgroundColor();
  }
}
class Q extends x {
  constructor(t, e) {
    super(t), this.color = e;
  }
  getVirtualPixelColor() {
    return this.color;
  }
}
class Tt extends x {
  getVirtualPixelColor(t, e) {
    return this.decorated.getPixelColor(Math.max(0, Math.min(this.width - 1, t)), Math.max(0, Math.min(this.height - 1, e)));
  }
}
class bt extends x {
  getVirtualPixelColor(t, e) {
    if (e < 0 || e >= this.height)
      return this.decorated.getPixelColor(Math.max(0, Math.min(this.width - 1, t)), Math.max(0, Math.min(this.height - 1, e)));
    const i = t % this.width, s = e % this.height;
    return this.decorated.getPixelColor(i < 0 ? this.width + i : i, s < 0 ? this.height + s : s);
  }
}
class Bt extends x {
  getVirtualPixelColor(t, e) {
    if (e < 0 || e >= this.height)
      return this.decorated.getBackgroundColor();
    const i = t % this.width, s = e % this.height;
    return this.decorated.getPixelColor(i < 0 ? this.width + i : i, s < 0 ? this.height + s : s);
  }
}
class Lt extends x {
  getVirtualPixelColor(t, e) {
    const i = 2 * this.width, s = 2 * this.height, o = t % i, a = e % s;
    let n = o < 0 ? i + o : o, l = a < 0 ? s + a : a;
    return n > this.width - 1 && (n = this.width - (n - this.width) - 1), l > this.height - 1 && (l = this.height - (l - this.height) - 1), this.decorated.getPixelColor(n, l);
  }
}
class St extends x {
  getVirtualPixelColor() {
    return this.decorated.getPixelColor(Math.floor(Math.random() * this.width), Math.floor(Math.random() * this.height));
  }
}
class Ot extends x {
  getVirtualPixelColor(t, e) {
    const i = t % this.width, s = e % this.height;
    return this.decorated.getPixelColor(i < 0 ? this.width + i : i, s < 0 ? this.height + s : s);
  }
}
class Dt extends x {
  getVirtualPixelColor(t, e) {
    if (t < 0 || t >= this.width)
      return this.decorated.getPixelColor(Math.max(0, Math.min(this.width - 1, t)), Math.max(0, Math.min(this.height - 1, e)));
    const i = t % this.width, s = e % this.height;
    return this.decorated.getPixelColor(i < 0 ? this.width + i : i, s < 0 ? this.height + s : s);
  }
}
class kt extends x {
  getVirtualPixelColor(t, e) {
    if (t < 0 || t >= this.width)
      return this.decorated.getBackgroundColor();
    const i = t % this.width, s = e % this.height;
    return this.decorated.getPixelColor(i < 0 ? this.width + i : i, s < 0 ? this.height + s : s);
  }
}
var p = ((r) => (r[r.BACKGROUND = 1] = "BACKGROUND", r[r.EDGE = 3] = "EDGE", r[r.MIRROR = 4] = "MIRROR", r[r.RANDOM = 5] = "RANDOM", r[r.TILE = 6] = "TILE", r[r.TRANSPARENT = 7] = "TRANSPARENT", r[r.BLACK = 9] = "BLACK", r[r.GRAY = 10] = "GRAY", r[r.WHITE = 11] = "WHITE", r[r.HORIZONTAL_TILE = 12] = "HORIZONTAL_TILE", r[r.VERTICAL_TILE = 13] = "VERTICAL_TILE", r[r.HORIZONTAL_TILE_EDGE = 14] = "HORIZONTAL_TILE_EDGE", r[r.VERTICAL_TILE_EDGE = 15] = "VERTICAL_TILE_EDGE", r))(p || {});
class Nt {
  decorate(t, e) {
    switch (e) {
      case p.BACKGROUND:
        return new It(t);
      case p.EDGE:
        return new Tt(t);
      case p.MIRROR:
        return new Lt(t);
      case p.RANDOM:
        return new St(t);
      case p.TILE:
        return new Ot(t);
      case p.TRANSPARENT:
        return new Q(t, [0, 0, 0, 0]);
      case p.BLACK:
        return new Q(t, [0, 0, 0, t.getQuantumRange()]);
      case p.GRAY:
        return new Q(t, [Math.floor(t.getQuantumRange() / 2), Math.floor(t.getQuantumRange() / 2), Math.floor(t.getQuantumRange() / 2), t.getQuantumRange()]);
      case p.WHITE:
        return new Q(t, [t.getQuantumRange(), t.getQuantumRange(), t.getQuantumRange(), t.getQuantumRange()]);
      case p.HORIZONTAL_TILE:
        return new Bt(t);
      case p.VERTICAL_TILE:
        return new kt(t);
      case p.HORIZONTAL_TILE_EDGE:
        return new bt(t);
      case p.VERTICAL_TILE_EDGE:
        return new Dt(t);
      default:
        throw new TypeError(`Unknown Virtual Pixel Method "${e}" given.`);
    }
  }
}
function Gt(r) {
  return typeof r == "object" && r !== null && typeof r.getAverageColor == "function";
}
function Wt(r) {
  return typeof r == "object" && r !== null && typeof r.getBackgroundColor == "function";
}
function Ht(r) {
  return typeof r == "object" && r !== null && typeof r.getPixelColor == "function" && typeof r.setPixelColor == "function" && typeof r.getQuantumRange == "function";
}
function _t(r) {
  return typeof Ht(r) && typeof r.width == "number" && typeof r.height == "number";
}
class y {
  constructor(t, e, i, s) {
    this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = s;
  }
  static fromLiteral(t) {
    let e, i, s, o;
    return "width" in t && "height" in t ? (e = t.x || 0, i = t.y || 0, s = e + t.width - 1, o = i + t.height - 1) : (e = t.x1, i = t.y1, s = t.x2, o = t.y2), new y(e, i, s, o);
  }
  getWidth() {
    return this.x2 - this.x1 + 1;
  }
  getHeight() {
    return this.y2 - this.y1 + 1;
  }
  getArea() {
    return this.getWidth() * this.getHeight();
  }
  expand(t, e) {
    return this.x1 = Math.min(this.x1, t), this.x2 = Math.max(this.x2, t), this.y1 = Math.min(this.y1, e), this.y2 = Math.max(this.y2, e), this;
  }
  clone() {
    return new y(this.x1, this.y1, this.x2, this.y2);
  }
  fixBounds() {
    return this.x1 = Math.floor(this.x1 - 0.5), this.y1 = Math.floor(this.y1 - 0.5), this.x2 = Math.ceil(this.x2 - 0.5), this.y2 = Math.ceil(this.y2 - 0.5), this;
  }
  scale(t) {
    const e = this.getWidth() * t, i = this.getHeight() * t;
    return this.x1 = this.x1 * t, this.y1 = this.y1 * t, this.x2 = this.x1 + e - 1, this.y2 = this.y1 + i - 1, this;
  }
  reset() {
    const t = this.getWidth(), e = this.getHeight();
    return this.x1 = 0, this.y1 = 0, this.x2 = this.x1 + t - 1, this.y2 = this.y1 + e - 1, this;
  }
  offset(t, e) {
    return this.x1 += t, this.y1 += e, this.x2 += t, this.y2 += e, this;
  }
}
function j(r) {
  if (typeof r != "object" || r === null)
    return !1;
  const t = r;
  return "x1" in t && typeof t.x1 == "number" && "y1" in t && typeof t.y1 == "number" && "x2" in t && typeof t.x2 == "number" && "y2" in t && typeof t.y2 == "number" || "width" in t && typeof t.width == "number" && "height" in t && typeof t.height == "number" && (!("x" in t) || typeof t.x == "number") && (!("y" in t) || typeof t.y == "number");
}
function qt(r) {
  return _t(r) && typeof r.getViewport == "function";
}
function Ut(r) {
  return Vt(r) && typeof r.getWeightLookupTable == "function";
}
const F = Number.EPSILON === void 0 ? Math.pow(2, -52) : Number.EPSILON, Xt = Number.MAX_VALUE, D = Math.PI / 2, k = 2 * Math.PI;
function xt(r, t, e = 0.5) {
  const i = 1 - e, s = [0, 0, 0, 0];
  for (let o = 0; o < 4; o++)
    s[o] = Math.round(r[o] * e + t[o] * i);
  return s;
}
function Qt() {
  const r = {};
  return r.promise = new Promise((t, e) => {
    r.resolve = t, r.reject = e;
  }), r;
}
function ut(r) {
  return Math.PI * r / 180;
}
function st(r) {
  const t = r < 0 ? -1 : 1;
  return t * r >= F ? 1 / r : t / F;
}
function Yt(r, t) {
  (function(h, u) {
    const d = h.length;
    h.forEach((c) => {
      if (c.length !== d)
        throw new TypeError("Matrix must be square");
    }), u.forEach((c) => {
      if (c.length !== d)
        throw new TypeError("Augment matrix vector length must be same as matrix rank");
    });
  })(r, t), r = gt(r), t = gt(t);
  const e = r.length, i = t.length, s = new Array(e).fill(0), o = new Array(e).fill(0), a = new Array(e).fill(0);
  let n = 0, l = 0;
  for (let h = 0; h < e; h++) {
    let u = 0;
    for (let c = 0; c < e; c++)
      if (a[c] !== 1)
        for (let g = 0; g < e; g++)
          a[g] !== 0 ? a[g] > 1 && pt() : Math.abs(r[c][g]) >= u && (u = Math.abs(r[c][g]), l = c, n = g);
    if (a[n]++, l !== n) {
      for (let c = 0; c < e; c++)
        rt(r, l, c, n, c);
      for (let c = 0; c < i; c++)
        rt(t, c, l, c, n);
    }
    o[h] = l, s[h] = n, r[n][n] === 0 && pt();
    const d = st(r[n][n]);
    r[n][n] = 1;
    for (let c = 0; c < e; c++)
      r[n][c] *= d;
    for (let c = 0; c < i; c++)
      t[c][n] *= d;
    for (let c = 0; c < e; c++)
      if (c !== n) {
        const g = r[c][n];
        r[c][n] = 0;
        for (let f = 0; f < e; f++)
          r[c][f] -= g * r[n][f];
        for (let f = 0; f < i; f++)
          t[f][c] -= g * t[f][n];
      }
  }
  for (let h = e - 1; h >= 0; h--)
    if (s[h] !== o[h])
      for (let u = 0; u < e; u++)
        rt(r, u, o[h], u, s[h]);
  return t;
}
function rt(r, t, e, i, s) {
  r[t][e] !== r[i][s] && (r[t][e] += r[i][s], r[i][s] = r[t][e] - r[i][s], r[t][e] -= r[i][s]);
}
function gt(r) {
  return r.map((t) => t.slice());
}
function pt() {
  throw new TypeError("Can't solve given matrix using Gauss-Jordan method");
}
class ot {
  constructor(t, e = 1) {
    this.coefficients = [], this.results = [];
    for (let i = 0; i < t; i++)
      this.coefficients.push(new Array(t).fill(0));
    for (let i = 0; i < e; i++)
      this.results.push(new Array(t).fill(0));
  }
  addTerms(t, e) {
    const i = this.coefficients.length;
    for (let s = 0; s < i; s++) {
      for (let o = 0; o < i; o++)
        this.coefficients[o][s] += t[o] * t[s];
      for (let o = 0; o < this.results.length; o++)
        this.results[o][s] += e[o] * t[s];
    }
    return this;
  }
  solve() {
    return Yt(this.coefficients, this.results);
  }
}
function O(r, t, e = !1) {
  if (e) {
    const i = document.createElement("canvas");
    return i.width = r, i.height = t, i;
  }
  return new OffscreenCanvas(r, t);
}
function jt(r, t = new Image()) {
  return new Promise((e, i) => {
    const s = () => {
      t.onload = null, t.onerror = null;
    };
    t.onload = () => {
      s(), e(t);
    }, t.onerror = () => {
      s(), i(new Error(`Couldn't load image "${r}"`));
    }, t.src = r;
  });
}
function Ge(r) {
  if (r instanceof HTMLCanvasElement)
    return r;
  const t = O(r.width, r.height, !0), e = t.getContext("2d");
  if (!e)
    throw new Error("Couldn't get canvas context");
  return e.drawImage(r, 0, 0), t;
}
class $ extends Error {
  constructor(t) {
    super(t), this.name = "LensException", typeof Error.captureStackTrace == "function" ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error(t).stack;
  }
}
class $t extends $ {
  constructor(t) {
    super(t), this.name = "AbortException";
  }
}
class B extends $ {
  constructor(t) {
    super(t), this.name = "InvalidArgument";
  }
}
class at extends $ {
  constructor(t) {
    super(t), this.name = "InvalidArgumentsLength";
  }
}
class We extends $ {
  constructor(t) {
    super(t), this.name = "InvalidMethodCall";
  }
}
function Kt(r, t, e) {
  return [e[0] * r + e[1] * t + e[2], e[3] * r + e[4] * t + e[5]];
}
function dt(r) {
  const t = st(r[0] * r[4] - r[1] * r[3]);
  if (!t)
    throw new B("Given matrix can't be inverted");
  return [t * r[4], t * -r[1], t * (r[1] * r[5] - r[2] * r[4]), t * -r[3], t * r[0], t * (r[2] * r[3] - r[0] * r[5])];
}
class G {
  constructor(t) {
    this.matrix = t, this.isConstantPartialDerivatives = !0, this.forwardMatrix = dt(t);
  }
  static fromForwardMatrix(t) {
    return new G(dt(t));
  }
  reverseMap(t, e) {
    return [this.matrix[0] * t + this.matrix[1] * e + this.matrix[2], this.matrix[3] * t + this.matrix[4] * e + this.matrix[5]];
  }
  getValidity() {
    return 1;
  }
  getPartialDerivatives() {
    return [this.matrix[0], this.matrix[1], this.matrix[3], this.matrix[4]];
  }
  forwardMap(t, e) {
    return Kt(t, e, this.forwardMatrix);
  }
  getBestFitViewport(t) {
    const e = t.x1, i = t.y1, s = t.x2 + 1, o = t.y2 + 1, [a, n] = this.forwardMap(e, i), l = new y(a, n, a, n);
    return [[s, i], [s, o], [e, o]].forEach((h) => l.expand(...this.forwardMap(...h))), l.fixBounds(), l;
  }
}
class Zt {
  create(t) {
    if (!t.length || t.length % 4 != 0)
      throw new at(`Number of arguments must be multiple of 4 and at least 4 arguments (1 control point) expected.${t.length} arguments given.`);
    if (t.length === 4)
      return new G([1, 0, t[0] - t[2], 0, 1, t[1] - t[3]]);
    {
      const e = new ot(3, 2);
      for (let s = 0; s < t.length; s += 4) {
        const [o, a, n, l] = t.slice(s, s + 4);
        e.addTerms([n, l, 1], [o, a]);
      }
      t.length === 8 && e.addTerms([t[2] - (t[7] - t[3]), t[3] + (t[6] - t[2]), 1], [t[0] - t[5] + t[1], t[1] + t[4] - t[0]]);
      const i = e.solve();
      return new G(i[0].concat(i[1]));
    }
  }
}
class zt {
  create(t) {
    const [e, i, s, o, a, n] = t;
    return G.fromForwardMatrix([e, s, a, i, o, n]);
  }
}
class Jt {
  constructor(t, e, i, s, o, a) {
    this.isConstantPartialDerivatives = !1, this.forceBestFit = !0, this.viewport = t, this.c0 = e, this.c1 = i, this.c2 = s, this.c3 = o, this.c4 = a, this.angleToWidth = k * this.viewport.getWidth() / this.c1, this.radiusToHeight = this.viewport.getHeight() / this.c3, this.viewportWidthX2 = 2 * this.viewport.getWidth();
  }
  reverseMap(t, e) {
    let [i, s] = this.getUV(t, e);
    return i = i * this.angleToWidth + this.c4 + this.viewport.x1 + 0.5, s = (this.c2 - s) * this.radiusToHeight + this.viewport.y1, [i, s];
  }
  getValidity() {
    return 1;
  }
  getPartialDerivatives(t, e) {
    const [, i] = this.getUV(t, e);
    return i > F ? [this.angleToWidth / (k * i), 0, 0, this.radiusToHeight] : [this.viewportWidthX2, 0, 0, this.radiusToHeight];
  }
  getBestFitViewport(t) {
    let e = this.c0 - this.c1 / 2, i = Math.cos(e), s = Math.sin(e), o = this.c2 * i, a = this.c2 * s;
    const n = new y(o, a, o, a);
    for (o = (this.c2 - this.c3) * i, a = (this.c2 - this.c3) * s, n.expand(o, a), e = this.c0 + this.c1 / 2, i = Math.cos(e), s = Math.sin(e), o = this.c2 * i, a = this.c2 * s, n.expand(o, a), o = (this.c2 - this.c3) * i, a = (this.c2 - this.c3) * s, n.expand(o, a), e = Math.ceil((this.c0 - this.c1 / 2) / D) * D; e < this.c0 + this.c1 / 2; e += D)
      i = Math.cos(e), s = Math.sin(e), o = this.c2 * i, a = this.c2 * s, n.expand(o, a);
    return n.fixBounds(), n;
  }
  getUV(t, e) {
    let i = (Math.atan2(e, t) - this.c0) / k;
    return i -= Math.round(i), [i, Math.hypot(t, e)];
  }
}
class te {
  create(t, e) {
    if (t.length >= 1 && t[0] < F)
      throw new B("Angle too small");
    if (t.length >= 3 && t[2] !== void 0 && t[2] < F)
      throw new B("Outer radius too small");
    let i, s, o, a;
    i = -D, s = t.length >= 1 ? ut(t[0]) : D, t.length >= 2 && t[1] !== void 0 && (i += ut(t[1])), i /= k, i -= Math.round(i), i *= k, a = e.getHeight() - 1, o = e.getWidth() / s + a / 2, t.length >= 3 && t[2] !== void 0 && t[3] !== void 0 && (t.length >= 4 ? a = t[2] - t[3] : a *= t[2] / o, o = t[2]);
    const n = (e.getWidth() - 1) / 2;
    return new Jt(e, i, s, o, a, n);
  }
}
function ft(r) {
  const t = st(r[0] * r[4] - r[3] * r[1]);
  if (!t)
    throw new B("Given matrix can't be inverted");
  return [t * (r[4] - r[7] * r[5]), t * (r[7] * r[2] - r[1]), t * (r[1] * r[5] - r[4] * r[2]), t * (r[6] * r[5] - r[3]), t * (r[0] - r[6] * r[2]), t * (r[3] * r[2] - r[0] * r[5]), t * (r[3] * r[7] - r[6] * r[4]), t * (r[6] * r[1] - r[0] * r[7])];
}
function ee(r, t, e) {
  const i = e[0] * r + e[1] * t + e[2], s = e[3] * r + e[4] * t + e[5], o = e[6] * r + e[7] * t + 1;
  return [i / o, s / o];
}
class K {
  constructor(t, e) {
    this.isConstantPartialDerivatives = !1, this.matrix = t, this.denominator = e, this.forwardMatrix = ft(t), this.absC6 = Math.abs(t[6]), this.absC7 = Math.abs(t[7]);
  }
  static fromForwardMatrix(t) {
    const e = ft(t), i = e[6] * t[2] + e[7] * t[5] + 1 < 0 ? -1 : 1;
    return new K(e, i);
  }
  reverseMap(t, e) {
    const i = this.matrix[0] * t + this.matrix[1] * e + this.matrix[2], s = this.matrix[3] * t + this.matrix[4] * e + this.matrix[5], o = this.matrix[6] * t + this.matrix[7] * e + 1;
    return [i / o, s / o];
  }
  getValidity(t, e, i) {
    const s = this.matrix[6] * t + this.matrix[7] * e + 1;
    let o = s * this.denominator < 0 ? 0 : 1;
    const a = 2 * Math.abs(s);
    return this.absC6 > this.absC7 ? a < this.absC6 && (o = 0.5 - this.denominator * s / (this.matrix[6] * i)) : a < this.absC7 && (o = 0.5 - this.denominator * s / (this.matrix[7] * i)), o;
  }
  getPartialDerivatives(t, e) {
    const i = this.matrix[0] * t + this.matrix[1] * e + this.matrix[2], s = this.matrix[3] * t + this.matrix[4] * e + this.matrix[5], o = this.matrix[6] * t + this.matrix[7] * e + 1, a = Math.pow(1 / o, 2);
    return [(o * this.matrix[0] - i * this.matrix[6]) * a, (o * this.matrix[1] - i * this.matrix[7]) * a, (o * this.matrix[3] - s * this.matrix[6]) * a, (o * this.matrix[4] - s * this.matrix[7]) * a];
  }
  forwardMap(t, e) {
    return ee(t, e, this.forwardMatrix);
  }
  getBestFitViewport(t) {
    const e = t.x1, i = t.y1, s = t.x2 + 1, o = t.y2 + 1, [a, n] = this.forwardMap(e, i), l = new y(a, n, a, n);
    return [[s, i], [s, o], [e, o]].forEach((h) => l.expand(...this.forwardMap(...h))), l.fixBounds(), l;
  }
}
class re {
  create(t) {
    if (t.length < 16 || t.length % 4 != 0)
      throw new at(`Number of arguments must be multiple of 4 and at least 16 arguments (4 control points) expected. ${t.length} arguments given.`);
    const e = new ot(8, 1);
    for (let o = 0; o < t.length; o += 4) {
      const [a, n, l, h] = t.slice(o, o + 4);
      e.addTerms([l, h, 1, 0, 0, 0, -l * a, -h * a], [a]).addTerms([0, 0, 0, l, h, 1, -l * n, -h * n], [n]);
    }
    const i = e.solve()[0], s = i[6] * t[2] + i[7] * t[3] + 1 < 0 ? -1 : 1;
    return new K(i, s);
  }
}
class ie {
  create(t) {
    return K.fromForwardMatrix(t);
  }
}
class se {
  constructor(t) {
    this.coeffs = t, this.isConstantPartialDerivatives = !1;
  }
  reverseMap(t, e) {
    const i = this.coeffs[1];
    let s = 0, o = 0;
    for (let a = 0; a < i; a++) {
      const n = vt(a, t, e);
      s += n * this.coeffs[2 + a], o += n * this.coeffs[2 + a + i];
    }
    return [s, o];
  }
  getValidity() {
    return 1;
  }
  getPartialDerivatives(t, e) {
    const i = this.coeffs[1];
    let s = 0, o = 0, a = 0, n = 0;
    for (let l = 0; l < i; l++) {
      const h = yt(l, t, e), u = ae(l, t, e), d = 2 + l, c = d + i;
      s = h * this.coeffs[d], o = u * this.coeffs[d], a = h * this.coeffs[c], n = u * this.coeffs[c];
    }
    return [s, o, a, n];
  }
}
class oe {
  create(t) {
    const e = function(s) {
      if (s < 1 || s > 5 || s != Math.floor(s) && s - 1.5 > F)
        throw new B(`Invalid polynomial order: ${s}`);
      return Math.floor((s + 1) * (s + 2) / 2);
    }(t[0]);
    if (t.length < 1 + 4 * e)
      throw new at(`Polynomial distortion of order ${t[0]} requires at least ${e} control point pairs (1 + ${4 * e} arguments)`);
    const i = new ot(e, 2);
    for (let s = 1; s < t.length; s += 4) {
      const o = [];
      for (let a = 0; a < e; a++)
        o[a] = vt(a, t[s + 2], t[s + 3]);
      i.addTerms(o, t.slice(s, s + 2));
    }
    return new se([t[0], e].concat(i.solve().flat()));
  }
}
function vt(r, t, e) {
  switch (r) {
    case 0:
      return 1;
    case 1:
      return t;
    case 2:
      return e;
    case 3:
      return t * e;
    case 4:
      return t * t;
    case 5:
      return e * e;
    case 6:
      return t * t * t;
    case 7:
      return t * t * e;
    case 8:
      return t * e * e;
    case 9:
      return e * e * e;
    case 10:
      return t * t * t * t;
    case 11:
      return t * t * t * e;
    case 12:
      return t * t * e * e;
    case 13:
      return t * e * e * e;
    case 14:
      return e * e * e * e;
    case 15:
      return t * t * t * t * t;
    case 16:
      return t * t * t * t * e;
    case 17:
      return t * t * t * e * e;
    case 18:
      return t * t * e * e * e;
    case 19:
      return t * e * e * e * e;
    case 20:
      return e * e * e * e * e;
  }
  return 0;
}
function yt(r, t, e) {
  switch (r) {
    case 0:
    case 2:
    case 5:
    case 9:
    case 14:
    case 20:
      return 0;
    case 1:
      return 1;
    case 3:
      return e;
    case 4:
      return t;
    case 6:
      return t * t;
    case 7:
      return t * e;
    case 8:
      return e * e;
    case 10:
      return t * t * t;
    case 11:
      return t * t * e;
    case 12:
      return t * e * e;
    case 13:
      return e * e * e;
    case 15:
      return t * t * t * t;
    case 16:
      return t * t * t * e;
    case 17:
      return t * t * e * e;
    case 18:
      return t * e * e * e;
    case 19:
      return e * e * e * e;
  }
  return 0;
}
function ae(r, t, e) {
  switch (r) {
    case 0:
    case 1:
    case 4:
      return 0;
    case 2:
      return 1;
    case 3:
      return t;
    case 5:
      return e;
    default:
      return yt(r - 1, t, e);
  }
}
class ne {
  constructor(t) {
    this.reversePixelMapperFactoriesPool = t;
  }
  resolve(t, e, i) {
    return this.reversePixelMapperFactoriesPool.get(t).create(e, i);
  }
}
function nt(r) {
  return typeof r == "object" && r !== null && typeof r.reverseMap == "function" && typeof r.getValidity == "function";
}
function mt(r) {
  return nt(r) && typeof r.getBestFitViewport == "function";
}
var E = ((r) => (r.AFFINE = "Affine", r.AFFINE_PROJECTION = "AffineProjection", r.PERSPECTIVE = "Perspective", r.PERSPECTIVE_PROJECTION = "PerspectiveProjection", r.ARC = "Arc", r.POLYNOMIAL = "Polynomial", r))(E || {});
function he(r) {
  return nt(r) && typeof r.getPartialDerivatives == "function" && typeof r.isConstantPartialDerivatives == "boolean";
}
function Y(r, t) {
  return Math.max(0, Math.min(t, r));
}
class le {
  constructor(t, e, i, s, o, a, n = [0, 0, 0, 0], l) {
    if (!he(e))
      throw new B("Pixel Mapper must implement ReversePixelMapperWithEwaSupport in order to use Elliptical Weighted Average re-sampling.");
    this.supportSq = s * s, this.matteColor = n, this.weightLookupTable = i, this.weightLookupTableSize = i.length, this.image = t, this.pixelMapper = e, this.imageViewport = this.image.getViewport(), this.imageArea = this.imageViewport.getArea(), this.imageVirtualPixelMethod = l, this.imageAverageColor = null, this.A = 0, this.B = 0, this.C = 0, this.F = 0, this.uLimit = 0, this.vLimit = 0, this.uWidth = 0, this.slope = 0, this.ellipseIsSetUp = !1, this.limitReached = !1, this.scaling = 1, this.quantumRange = t.getQuantumRange(), this.averageInterpolator = o, this.defaultInterpolator = a;
  }
  getWeightLookupTable() {
    return this.weightLookupTable;
  }
  getScaling() {
    return this.scaling;
  }
  setScaling(t) {
    return this.scaling = t, this;
  }
  getResampledColor(t, e) {
    t = (t + 0.5) * this.scaling, e = (e + 0.5) * this.scaling;
    const i = this.pixelMapper.getValidity(t, e, this.scaling);
    if (i > 0) {
      const [s, o] = this.pixelMapper.reverseMap(t, e);
      if (!this.pixelMapper.isConstantPartialDerivatives || !this.ellipseIsSetUp) {
        const n = this.pixelMapper.getPartialDerivatives(t, e);
        this.setupEllipse(n[0], n[1], n[2], n[3]), this.ellipseIsSetUp = !0;
      }
      const a = this.getWeightedAverage(s - 0.5, o - 0.5);
      return i < 1 ? xt(a, this.matteColor, i) : a;
    }
    return this.matteColor;
  }
  setupEllipse(t, e, i, s) {
    this.limitReached = !1;
    const o = this.scaling;
    return this.initEllipse(t * o, e * o, i * o, s * o).scaleEllipse();
  }
  initEllipse(t, e, i, s) {
    const [o, a, n, l, h, u] = function(d, c, g, f) {
      const v = d * d + c * c, H = d * g + c * f, Z = H, C = g * g + f * f, V = d * f - c * g, _ = V + V, R = v + C, P = (R + _) * (R - _), I = Math.sqrt(P > 0 ? P : 0), A = 0.5 * (R + I), T = 0.5 * (R - I), m = A - v, L = A - C, q = m * m, U = L * L, b = q >= U ? H : L, z = q >= U ? m : Z, X = Math.sqrt(b * b + z * z), lt = X > 0 ? b / X : 1, ct = X > 0 ? z / X : 0, J = A <= 1 ? 1 : Math.sqrt(A), tt = T <= 1 ? 1 : Math.sqrt(T);
      return [lt * J, ct * J, -ct * tt, lt * tt, J, tt];
    }(t, e, i, s);
    return this.A = a * a + l * l, this.B = -2 * (o * a + n * l), this.C = o * o + n * n, this.F = h * u, this.F *= this.F, this.limitReached = 4 * this.A * this.C - this.B * this.B > Xt, this;
  }
  scaleEllipse() {
    if (!this.limitReached) {
      if (this.F *= this.supportSq, this.uLimit = Math.sqrt(this.C * this.F / (this.A * this.C - 0.25 * this.B * this.B)), this.vLimit = Math.sqrt(this.A * this.F / (this.A * this.C - 0.25 * this.B * this.B)), this.uWidth = Math.sqrt(this.F / this.A), this.slope = -this.B / (2 * this.A), this.uWidth * this.vLimit > 4 * this.imageArea)
        return this.limitReached = !0, this;
      const t = this.weightLookupTableSize / this.F;
      this.A *= t, this.B *= t, this.C *= t;
    }
    return this;
  }
  getWeightedAverage(t, e) {
    if (this.doesntNeedResampling(t, e))
      return this.image.getPixelColor(t, e);
    if (this.limitReached)
      switch (this.imageVirtualPixelMethod) {
        case p.EDGE:
        case p.HORIZONTAL_TILE_EDGE:
        case p.VERTICAL_TILE_EDGE:
          return this.averageInterpolator.interpolate(this.image, t, e);
        case p.HORIZONTAL_TILE:
        case p.VERTICAL_TILE:
          return this.image.getPixelColor(this.imageViewport.x1 - 1, this.imageViewport.y1 - 1);
        default:
          return this.getImageAverageColor();
      }
    let i = 0, s = 0, o = 0, a = 0, n = 0, l = 0;
    const h = Math.ceil(e - this.vLimit), u = Math.floor(e + this.vLimit);
    let d = t + (h - e) * this.slope - this.uWidth;
    const c = 2 * this.uWidth + 1, g = this.A, f = this.B, v = this.image, H = this.weightLookupTable, Z = 2 * g;
    for (let C = h; C < u; C++) {
      const V = Math.ceil(d);
      d += this.slope;
      const _ = V + c, R = V - t, P = C - e;
      let I = (g * R + f * P) * R + this.C * P * P, A = g * (2 * R + 1) + f * P;
      for (let T = V; T < _; T++) {
        if (I < this.weightLookupTableSize) {
          let m = H[Math.floor(I)];
          const [L, q, U, b] = v.getPixelColor(T, C);
          l += m * b, i += m, m *= b / this.quantumRange, o += L * m, a += q * m, n += U * m, s += m;
        }
        I += A, A += Z;
      }
    }
    return s && i ? [Y(Math.round(o / s), this.quantumRange), Y(Math.round(a / s), this.quantumRange), Y(Math.round(n / s), this.quantumRange), Y(Math.round(l / i), this.quantumRange)] : this.defaultInterpolator.interpolate(this.image, t, e);
  }
  doesntNeedResampling(t, e) {
    switch (this.imageVirtualPixelMethod) {
      case p.TRANSPARENT:
      case p.BACKGROUND:
      case p.BLACK:
      case p.WHITE:
      case p.GRAY:
        return this.limitReached || this.outOfImageBounds(t, e);
      case p.EDGE:
        return t + this.uLimit < this.imageViewport.x1 && e + this.vLimit < this.imageViewport.y1 || t + this.uLimit < this.imageViewport.x1 && e - this.vLimit > this.imageViewport.y2 || t - this.uLimit > this.imageViewport.x2 && e + this.vLimit < this.imageViewport.y1 || t - this.uLimit > this.imageViewport.x2 && e - this.vLimit > this.imageViewport.y2;
      case p.HORIZONTAL_TILE:
        return e + this.vLimit < this.imageViewport.y1 || e - this.vLimit > this.imageViewport.y2;
      case p.VERTICAL_TILE:
        return t + this.uLimit < this.imageViewport.x1 || t - this.uLimit > this.imageViewport.x2;
      default:
        return !1;
    }
  }
  getImageAverageColor() {
    return this.imageAverageColor === null && (this.imageAverageColor = this.image.getAverageColor()), this.imageAverageColor;
  }
  outOfImageBounds(t, e) {
    return t + this.uLimit < this.imageViewport.x1 || t - this.uLimit > this.imageViewport.x2 || e + this.vLimit < this.imageViewport.y1 || e - this.vLimit > this.imageViewport.y2;
  }
}
class ce {
  constructor(t) {
    this.colorInterpolatorFactory = t, this.supportsEwa = !0, this.requiresResampleFilter = !0;
  }
  create(t, e, i = {}) {
    const { resampleFilter: s, matteColor: o = [0, 0, 0, 0], interpolationMethod: a = w.AVERAGE, virtualPixelMethod: n = p.TRANSPARENT } = i;
    if (!s)
      throw new TypeError("EWA resampler requires ResampleFilter.");
    const l = function(c) {
      const g = [], f = c.getWorkingSupport() * Math.sqrt(1 / wt);
      for (let v = 0; v < wt; v++)
        g[v] = c.getWeight(Math.sqrt(v) * f);
      return g;
    }(s), h = s.getWorkingSupport(), u = this.colorInterpolatorFactory.create(w.AVERAGE), d = a === w.AVERAGE ? u : this.colorInterpolatorFactory.create(a);
    return new le(t, e, l, h, u, d, o, n);
  }
}
const wt = 1024;
class ue {
  constructor(t, e, i, s = [0, 0, 0, 0]) {
    this.image = t, this.pixelMapper = e, this.interpolator = i, this.matteColor = s, this.scaling = 1;
  }
  getScaling() {
    return this.scaling;
  }
  setScaling(t) {
    return this.scaling = t, this;
  }
  getResampledColor(t, e) {
    t = (t + 0.5) * this.scaling, e = (e + 0.5) * this.scaling;
    const i = this.pixelMapper.getValidity(t, e, this.scaling);
    if (i > 0) {
      const [s, o] = this.pixelMapper.reverseMap(t, e), a = this.interpolator.interpolate(this.image, s - 0.5, o - 0.5);
      return i < 1 ? xt(a, this.matteColor, i) : a;
    }
    return this.matteColor;
  }
}
class ge {
  constructor(t) {
    this.colorInterpolatorFactory = t, this.supportsEwa = !1, this.requiresResampleFilter = !1;
  }
  create(t, e, i = {}) {
    const { matteColor: s = [0, 0, 0, 0], interpolationMethod: o = w.AVERAGE } = i;
    return new ue(t, e, this.colorInterpolatorFactory.create(o), s);
  }
}
class pe {
  constructor(t) {
    this.parsersPool = t;
  }
  parse(t, e = 255) {
    for (const i of this.parsersPool.items()) {
      const s = i.parse(t, e);
      if (s)
        return s;
    }
  }
}
class de {
  parse(t, e = 255) {
    /^#[a-f\d]{3}$/i.test(t) && (t = "#" + t.slice(1).split("").map((s) => s.repeat(2)).join(""));
    const i = t.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i);
    if (i)
      return [Math.round(parseInt(i[1], 16) / 255 * e), Math.round(parseInt(i[2], 16) / 255 * e), Math.round(parseInt(i[3], 16) / 255 * e), i[4] ? Math.round(parseInt(i[4], 16) / 255 * e) : e];
  }
}
function Rt(r) {
  return !!Array.isArray(r) && r.length === 4 && r.every((t) => typeof t == "number");
}
function Ct(r) {
  return Array.isArray(r) && r.length === 2 && typeof r[0] == "number" && typeof r[1] == "number";
}
class fe {
  parse(t, e = 255) {
    if (!/^\s*rgba?/.test(t))
      return;
    const i = t.replace(/\s/g, "").match(/(\d+(\.\d+)?%?)|(\.\d+%?)/g);
    if (!i || i.length < 3)
      return;
    i.length === 3 && i.push("1");
    const s = i.map((o, a) => {
      const n = parseFloat(o);
      return a === 3 ? Math.round(n * e) : o.indexOf("%") !== -1 ? Math.round(n / 100 * e) : Math.round(n / 255 * e);
    }).filter((o) => !isNaN(o));
    return Rt(s) ? s : void 0;
  }
}
class me {
  parse(t) {
    if (t === "transparent")
      return [0, 0, 0, 0];
  }
}
class we {
  constructor(t, e) {
    this.asyncTimeout = t, this.abortSignal = e;
  }
  async process(t, e) {
    const i = this.createProcessScope(t, e);
    return this.doProcess(i, this.asyncTimeout), await i.deferred.promise, t.commit(), t;
  }
  createProcessScope(t, e) {
    const i = t.getViewport(), s = Math.floor(i.x1), o = Math.floor(i.x2), a = Math.floor(i.y2), n = s, l = Math.floor(i.y1);
    return { deferred: Qt(), image: t, resampler: e, startX: s, endX: o, endY: a, currentX: n, currentY: l };
  }
  doProcess(t, e) {
    if (this.abortSignal && this.abortSignal.aborted)
      return void t.deferred.reject(this.abortSignal.reason instanceof Error ? this.abortSignal.reason : new $t(String(this.abortSignal.reason)));
    const i = Date.now(), { image: s, resampler: o, startX: a, endX: n, endY: l } = t;
    let { currentX: h, currentY: u } = t;
    for (; u <= l; ) {
      for (; h <= n; )
        if (s.setPixelColor(h, u, o.getResampledColor(h, u)), h++, Date.now() - i >= e)
          return t.currentX = h, t.currentY = u, void setTimeout(this.doProcess.bind(this, t, e), 0);
      u++, h = a;
    }
    t.deferred.resolve();
  }
}
class xe {
  constructor(t, e) {
    this.processor = t, this.superSamplingFactor = e;
  }
  async process(t, e) {
    this.superSamplingFactor !== 1 && e.setScaling(1 / this.superSamplingFactor);
    const i = await this.processor.process(t, e);
    return this.superSamplingFactor !== 1 ? i.scale(1 / this.superSamplingFactor) : i;
  }
}
class ve {
  constructor(t, e) {
    this.width = t, this.height = e, this.viewport = new y(0, 0, this.width - 1, this.height - 1), this.backgroundColor = [0, 0, 0, 0], this.quantumRange = 255;
  }
  getViewport() {
    return this.viewport;
  }
  setViewport(t) {
    return this.viewport = t, this;
  }
  getBackgroundColor() {
    return this.backgroundColor;
  }
  setBackgroundColor(t) {
    return this.backgroundColor = t, this;
  }
  getQuantumRange() {
    return this.quantumRange;
  }
  getBlank(t) {
    const e = this.prepareBlank(t.getWidth(), t.getHeight());
    return e.setViewport(t), this.duplicateProps(e);
  }
  scale(t) {
    const e = this.viewport.clone();
    e.scale(t);
    const i = this.resize(e.getWidth(), e.getHeight());
    return i.setViewport(e), this.duplicateProps(i);
  }
  duplicateProps(t) {
    return t.setBackgroundColor(this.backgroundColor), t;
  }
}
class ye {
  constructor(t) {
    this.factoriesPool = t;
  }
  resolve(t) {
    const e = this.factoriesPool.items().find((s) => s.match(t));
    if (e)
      return e.create(t);
    const i = Object.prototype.toString.call(t).slice(8, -1);
    throw new TypeError(`No matching image adapter factory for resource of type ${i}`);
  }
}
function S(r) {
  const t = r.getContext("2d", { willReadFrequently: !0 });
  if (!t)
    throw new Error("Couldn't get canvas context");
  return t;
}
class N extends ve {
  constructor(t) {
    super(t.width, t.height), this.canvas = t, this.imageData = S(t).getImageData(0, 0, t.width, t.height), this.data = this.imageData.data;
  }
  static createFromImage(t) {
    const e = O(t.width, t.height);
    return S(e).drawImage(t, 0, 0), new N(e);
  }
  static async createFromUrl(t) {
    const e = await jt(t);
    return this.createFromImage(e);
  }
  static async createFromBlob(t) {
    const e = await createImageBitmap(t);
    return this.createFromImage(e);
  }
  getPixelColor(t, e) {
    const i = 4 * (e * this.width + t);
    return [this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]];
  }
  setPixelColor(t, e, i) {
    const s = 4 * (e * this.width + t);
    this.data[s] = i[0], this.data[s + 1] = i[1], this.data[s + 2] = i[2], this.data[s + 3] = i[3];
  }
  getAverageColor() {
    const t = S(O(1, 1));
    return t.drawImage(this.canvas, 0, 0, this.width, this.height, 0, 0, 1, 1), Array.prototype.slice.call(t.getImageData(0, 0, 1, 1).data);
  }
  resize(t, e) {
    const i = O(t, e, !this.isOffscreen());
    return S(i).drawImage(this.canvas, 0, 0, this.width, this.height, 0, 0, t, e), new N(i);
  }
  getResource() {
    return this.canvas;
  }
  prepareBlank(t, e) {
    return new N(O(t, e, !this.isOffscreen()));
  }
  commit() {
    S(this.canvas).putImageData(this.imageData, 0, 0);
  }
  isOffscreen() {
    return typeof OffscreenCanvas !== void 0 && this.canvas instanceof OffscreenCanvas;
  }
}
class Re {
  match(t) {
    return typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas;
  }
  create(t) {
    return new N(t);
  }
}
function Ce(r) {
  return qt(r) && Gt(r) && Wt(r) && typeof r.setViewport == "function" && typeof r.setBackgroundColor == "function" && typeof r.getBlank == "function" && typeof r.scale == "function" && typeof r.getResource == "function" && typeof r.commit == "function";
}
class W {
  constructor(t) {
    this.adapter = t, { x1: this.offsetX, y1: this.offsetY } = t.getViewport(), { width: this.width, height: this.height } = t;
  }
  getAdapter() {
    return this.adapter;
  }
  getPixelColor(t, e) {
    return this.adapter.getPixelColor(Math.floor(t - this.offsetX), Math.floor(e - this.offsetY));
  }
  setPixelColor(t, e, i) {
    this.adapter.setPixelColor(Math.floor(t - this.offsetX), Math.floor(e - this.offsetY), i);
  }
  getViewport() {
    return this.adapter.getViewport();
  }
  setViewport(t) {
    this.adapter.setViewport(t), { x1: this.offsetX, y1: this.offsetY } = t;
  }
  getBackgroundColor() {
    return this.adapter.getBackgroundColor();
  }
  setBackgroundColor(t) {
    this.adapter.setBackgroundColor(t);
  }
  getAverageColor() {
    return this.adapter.getAverageColor();
  }
  getQuantumRange() {
    return this.adapter.getQuantumRange();
  }
  getBlank(t) {
    const e = this.adapter.getBlank(t);
    return new W(e);
  }
  scale(t) {
    const e = this.adapter.scale(t);
    return new W(e);
  }
  getResource() {
    return this.adapter.getResource();
  }
  commit() {
    return this.adapter.commit();
  }
}
class Pe {
  constructor(t, e) {
    this.processor = t, this.repage = e;
  }
  async process(t, e) {
    const i = await this.processor.process(t, e);
    return i.getViewport().reset(), Ct(this.repage) ? i.getViewport().offset(...this.repage) : j(this.repage) && i.setViewport(y.fromLiteral(this.repage)), i;
  }
}
class Ae {
  create(t = {}) {
    const { asyncTimeout: e = 50, outputScaling: i = 1, repage: s = !1, abortSignal: o } = t;
    let a = new we(e, o);
    return i !== 1 && (a = new xe(a, i)), s && (a = new Pe(a, Ct(s) || j(s) ? s : void 0)), a;
  }
}
class Me {
  constructor(t, e) {
    this.outputViewportResolver = t, this.distortionProcessorFactory = e;
  }
  async distort(t, e, i, s = {}) {
    const { viewport: o = !1, outputScaling: a = 1, repage: n, asyncTimeout: l = 50, abortSignal: h } = s, u = this.createTargetImage(t, e, o, a), d = new W(u), c = this.distortionProcessorFactory.create({ outputScaling: a, repage: n, asyncTimeout: l, abortSignal: h }), g = await c.process(d, i);
    return g instanceof W ? g.getAdapter() : g;
  }
  createTargetImage(t, e, i, s) {
    const o = this.outputViewportResolver.resolve(t, e, i);
    return s !== 1 && o.scale(s), t.getBlank(o);
  }
}
class Ee {
  constructor(t, e, i, s, o, a) {
    this.reversePixelMapperResolver = t, this.colorResamplerResolver = e, this.distortionController = i, this.imageAdapterResolver = s, this.colorStringParser = o, this.virtualPixelDecoratorApplicator = a;
  }
  async distort(t, e, i, s) {
    const [o, a, n] = this.clarifyArguments(t, e, i, s);
    this.setImageAdapterOptions(o, n);
    const l = this.getColorResampler(o, a, n), h = Date.now(), u = await this.distortionController.distort(o, a, l, n), d = Date.now();
    return { image: u, distortion: a, startTimestamp: h, endTimestamp: d, duration: d - h, weightLookupTable: Ut(l) ? l.getWeightLookupTable() : void 0 };
  }
  resolveImageAdapter(t) {
    return Ce(t) ? t : this.imageAdapterResolver.resolve(t);
  }
  clarifyArguments(t, e, i, s) {
    const o = this.resolveImageAdapter(t);
    let a, n;
    if (nt(e)) {
      if (Array.isArray(i))
        throw new TypeError("Argument 3 should be options object or undefined when passing ReversePixelMapper as second argument");
      a = e, n = i;
    } else {
      if (!Array.isArray(i))
        throw new TypeError("Missing distortion arguments");
      a = this.reversePixelMapperResolver.resolve(e, i, o.getViewport()), n = s;
    }
    return [o, a, n || {}];
  }
  getColorResampler(t, e, i) {
    const { matteColor: s, filter: o = "RobidouxSharp", preferredResampler: a, virtualPixelMethod: n = p.TRANSPARENT, interpolationMethod: l = w.AVERAGE } = i, h = this.resolveColor(s, t.getQuantumRange()), u = this.virtualPixelDecoratorApplicator.decorate(t, n);
    return this.colorResamplerResolver.resolve(u, e, { preferredResampler: a, matteColor: h, filter: o, interpolationMethod: l, virtualPixelMethod: n });
  }
  setImageAdapterOptions(t, e) {
    const { imageBackgroundColor: i, imageViewportOffset: s } = e;
    t.setBackgroundColor(this.resolveColor(i, t.getQuantumRange())), s && t.getViewport().offset(...s);
  }
  resolveColor(t, e, i = [0, 0, 0, 0]) {
    return t === void 0 ? i : Rt(t) ? t : this.colorStringParser.parse(t, e) || i;
  }
}
class Fe {
  constructor(t) {
    this.outputViewportStrategiesPool = t;
  }
  resolve(t, e, i) {
    const s = this.outputViewportStrategiesPool.items();
    s.sort((a, n) => a.priority - n.priority);
    const o = s.find((a) => a.match(e, i));
    if (!o)
      throw new Error("Couldn't find matching output viewport resolution strategy");
    return o.getOutputViewport(t, e, i);
  }
}
class Ve {
  constructor() {
    this.priority = 2;
  }
  match(t, e) {
    return mt(t) && (t.forceBestFit || e === "bestFit" || e === !0);
  }
  getOutputViewport(t, e) {
    if (mt(e))
      return e.getBestFitViewport(t.getViewport());
    throw new TypeError("Given ReversePixelMapper don't support best-fit output viewport");
  }
}
class Ie {
  constructor() {
    this.priority = 3;
  }
  getOutputViewport(t) {
    return t.getViewport().clone();
  }
  match() {
    return !0;
  }
}
class Te {
  constructor() {
    this.priority = 1;
  }
  match(t, e) {
    return j(e);
  }
  getOutputViewport(t, e, i) {
    if (j(i))
      return y.fromLiteral(i);
    throw new TypeError("'viewport argument should be ViewportLiteral");
  }
}
class M {
  constructor() {
    this.storage = /* @__PURE__ */ new Map();
  }
  has(t) {
    return this.storage.has(t);
  }
  get(t) {
    const e = this.storage.get(t);
    if (e === void 0)
      throw new RangeError(`Item with key "${t}" was not found in pool.`);
    return e;
  }
  add(t, e, i = !1) {
    if (this.storage.has(t) && !i)
      throw new TypeError(`Item with key "${t}" already exists in pool`);
    this.storage.set(t, e);
  }
  remove(t) {
    this.storage.delete(t);
  }
  keys() {
    return Array.from(this.storage.keys());
  }
  items() {
    return Array.from(this.storage.values());
  }
}
class be {
  constructor(t, e, i, s, o = 1, a) {
    this.filterFunction = t, this.windowingFunction = e, this.support = i, this.scale = s, this.blur = o, this.windowSupport = a !== void 0 ? a : this.support;
  }
  getWorkingSupport() {
    return this.support * this.blur;
  }
  getWeight(t) {
    const e = t / this.blur;
    return (e < F ? 1 : this.window(this.scale * e)) * this.filter(e);
  }
  filter(t) {
    return this.filterFunction(t, this.support, this.windowSupport);
  }
  window(t) {
    return this.windowingFunction(t, this.support, this.windowSupport);
  }
}
class Be {
  constructor(t) {
    this.weightingFunctionFactoriesPool = t;
  }
  create(t, e, i, s, o, a, n = 1, l) {
    const h = this.weightingFunctionFactoriesPool.get(t).create(...e), u = this.weightingFunctionFactoriesPool.get(i).create(...s);
    return new be(h, u, o, a, n, l);
  }
}
function Le(r) {
  return typeof r == "object" && r !== null && typeof r.getWorkingSupport == "function" && typeof r.getWeight == "function";
}
function Se(r) {
  return typeof r == "object" && r !== null && typeof r.filterFunctionFactory == "string" && Array.isArray(r.filterFunctionFactoryArgs) && typeof r.windowFunctionFactory == "string" && Array.isArray(r.windowFunctionFactoryArgs) && typeof r.support == "number" && typeof r.scale == "number";
}
class Oe {
  constructor(t, e) {
    this.filterPresetsPool = t, this.filterFactory = e;
  }
  resolve(t, e = {}) {
    if (Le(t))
      return t;
    let i;
    i = Se(t) ? t : this.filterPresetsPool.get(t);
    const { blur: s = 1, windowSupport: o } = i, { filterBlur: a = s, filterWindowSupport: n = o } = e;
    return this.filterFactory.create(i.filterFunctionFactory, i.filterFunctionFactoryArgs, i.windowFunctionFactory, i.windowFunctionFactoryArgs, i.support, i.scale, a, n);
  }
}
var De = ((r) => (r.ROBIDOUX = "Robidoux", r.ROBIDOUX_SHARP = "RobidouxSharp", r.BOX = "Box", r))(De || {});
class ht {
  constructor() {
    this.parent = null, this.services = /* @__PURE__ */ new Map(), this.backups = [];
  }
  register(t, e) {
    this.services.set(t, e);
  }
  unregister(t) {
    this.services.delete(t);
  }
  resolve(t) {
    const e = this.services.get(t);
    if (e === void 0) {
      if (this.parent)
        return this.parent.resolve(t);
      throw new RangeError(`Service "${t}" was not found in container.`);
    }
    return typeof e == "function" ? e(this) : e;
  }
  backup() {
    const t = new Map(this.services);
    this.backups.push(t);
  }
  restore() {
    const t = this.backups.pop();
    t && (this.services.clear(), this.services = t);
  }
  createChild() {
    const t = new ht();
    return t.parent = this, t;
  }
}
class ke {
  create() {
    return function() {
      return 1;
    };
  }
}
class Ne {
  create(t, e) {
    const i = (6 - 2 * t) / 6, s = (12 * t - 18 + 6 * e) / 6, o = (12 - 9 * t - 6 * e) / 6, a = (8 * t + 24 * e) / 6, n = (-12 * t - 48 * e) / 6, l = (6 * t + 30 * e) / 6, h = (-1 * t - 6 * e) / 6;
    return function(u) {
      if (typeof u == "number") {
        if (u < 1)
          return i + u * (u * (s + u * o));
        if (u < 2)
          return a + u * (n + u * (l + u * h));
      }
      return 0;
    };
  }
}
var it = ((r) => (r.BOX = "Box", r.CUBIC_BC = "CubicBC", r))(it || {});
const Pt = function(r = []) {
  const t = new ht();
  return r.forEach((e) => e.register(t)), t;
}([{ register(r) {
  let t = !1;
  r.register("ColorResamplerResolver", (e) => {
    if (!t) {
      const i = e.resolve("ColorInterpolatorFactory"), s = new M();
      s.add("ewa", new ce(i)), s.add("point", new ge(i)), e.register("ColorResamplerFactoriesPool", s), t = !0;
    }
    return new Ft(e.resolve("ColorResamplerFactoriesPool"), e.resolve("ResampleFilterResolver"));
  });
} }, { register(r) {
  const t = new M();
  t.add("transparent", new me()), t.add("hex", new de()), t.add("rgba", new fe()), r.register("ColorStringParsersPool", t), r.register("ColorStringParser", (e) => new pe(e.resolve("ColorStringParsersPool")));
} }, { register(r) {
  r.register("DistortionProcessorFactory", () => new Ae()), r.register("DistortionController", (t) => new Me(t.resolve("OutputViewportResolver"), t.resolve("DistortionProcessorFactory"))), r.register("DistortionService", (t) => new Ee(t.resolve("ReversePixelMapperResolver"), t.resolve("ColorResamplerResolver"), t.resolve("DistortionController"), t.resolve("ImageAdapterResolver"), t.resolve("ColorStringParser"), t.resolve("VirtualPixelDecoratorApplicator")));
} }, { register(r) {
  const t = new M();
  t.add("BrowserCanvas", new Re()), r.register("ImageAdapterFactoriesPool", t), r.register("ImageAdapterResolver", (e) => new ye(e.resolve("ImageAdapterFactoriesPool")));
} }, { register(r) {
  const t = new M();
  t.add("user-provided", new Te()), t.add("best-fit", new Ve()), t.add("source-image", new Ie()), r.register("OutputViewportStrategiesPool", t), r.register("OutputViewportResolver", (e) => new Fe(e.resolve("OutputViewportStrategiesPool")));
} }, { register(r) {
  const t = new M();
  t.add(E.ARC, new te()), t.add(E.AFFINE, new Zt()), t.add(E.AFFINE_PROJECTION, new zt()), t.add(E.PERSPECTIVE, new re()), t.add(E.PERSPECTIVE_PROJECTION, new ie()), t.add(E.POLYNOMIAL, new oe()), r.register("ReversePixelMapperFactoriesPool", t), r.register("ReversePixelMapperResolver", (e) => new ne(e.resolve("ReversePixelMapperFactoriesPool")));
} }, { register(r) {
  const t = new M();
  t.add("Robidoux", { filterFunctionFactory: "CubicBC", filterFunctionFactoryArgs: [0.3782157550939987, 0.3108921224530007], windowFunctionFactory: "Box", windowFunctionFactoryArgs: [], support: 2, scale: 1.1685777620836932 }), t.add("RobidouxSharp", { filterFunctionFactory: "CubicBC", filterFunctionFactoryArgs: [0.2620145123990142, 0.3689927438004929], windowFunctionFactory: "Box", windowFunctionFactoryArgs: [], support: 2, scale: 1.105822933719019 }), t.add("Box", { filterFunctionFactory: "Box", filterFunctionFactoryArgs: [], windowFunctionFactory: "Box", windowFunctionFactoryArgs: [], support: 0.5, scale: 0.5 }), r.register("ResampleFilterPresetsPool", t), r.register("ResampleFilterFactory", (e) => new Be(e.resolve("WeightingFunctionFactoriesPool"))), r.register("ResampleFilterResolver", (e) => new Oe(e.resolve("ResampleFilterPresetsPool"), e.resolve("ResampleFilterFactory")));
} }, { register(r) {
  const t = new M();
  t.add(it.BOX, new ke()), t.add(it.CUBIC_BC, new Ne()), r.register("WeightingFunctionFactoriesPool", t);
} }, { register(r) {
  r.register("ColorInterpolatorFactory", new Et());
} }, { register(r) {
  r.register("VirtualPixelDecoratorApplicator", new Nt());
} }]);
function He(r, t, e, i) {
  return Pt.resolve("DistortionService").distort(r, t, e, i);
}
async function _e(r, t, e, i) {
  return (await Pt.resolve("DistortionService").distort(r, t, e, i)).image.getResource();
}
const qe = "2.0.1";
export {
  $t as AbortException,
  ve as AbstractImageAdapter,
  x as AbstractVirtualPixelDecorator,
  G as Affine,
  Zt as AffineFactory,
  zt as AffineProjectionFactory,
  Jt as Arc,
  te as ArcFactory,
  et as AverageInterpolator,
  At as BackgroundInterpolator,
  It as BackgroundVirtualPixel,
  Et as BaseColorInterpolatorFactory,
  Ft as BaseColorResamplerResolver,
  Ae as BaseDistortionProcessorFactory,
  ye as BaseImageAdapterResolver,
  Fe as BaseOutputViewportResolver,
  M as BasePool,
  be as BaseResampleFilter,
  Be as BaseResampleFilterFactory,
  Oe as BaseResampleFilterResolver,
  ne as BaseReversePixelMapperResolver,
  ht as BaseServiceContainer,
  Nt as BaseVirtualPixelDecoratorApplicator,
  Ve as BestFitViewport,
  ke as BoxFactory,
  N as Canvas,
  Re as CanvasFactory,
  pe as CompositeColorStringParser,
  Q as ConstantVirtualPixel,
  Ne as CubicBCFactory,
  E as Distortion,
  Me as DistortionController,
  Ee as DistortionService,
  F as EPSILON,
  Tt as EdgeVirtualPixel,
  le as EwaResampler,
  ce as EwaResamplerFactory,
  De as FilterName,
  de as HexColorStringParser,
  bt as HorizontalTileEdgeVirtualPixel,
  Bt as HorizontalTileVirtualPixel,
  Mt as IntegerInterpolator,
  w as InterpolationMethod,
  B as InvalidArgument,
  at as InvalidArgumentsLength,
  We as InvalidMethodCall,
  ot as LeastSquares,
  $ as LensException,
  Xt as MAXIMUM_VALUE,
  k as M_2PI,
  D as M_PI2,
  Lt as MirrorVirtualPixel,
  K as Perspective,
  re as PerspectiveFactory,
  ie as PerspectiveProjectionFactory,
  ue as PointResampler,
  ge as PointResamplerFactory,
  se as Polynomial,
  oe as PolynomialFactory,
  St as RandomVirtualPixel,
  Pe as RepageProxy,
  we as ReversePixelMappingProcessor,
  fe as RgbaColorStringParser,
  Ie as SourceImageViewport,
  xe as SuperSamplingProxy,
  Ot as TileVirtualPixel,
  me as TransparentStringParser,
  Te as UserProvidedViewport,
  qe as VERSION,
  Dt as VerticalTileEdgeVirtualPixel,
  kt as VerticalTileVirtualPixel,
  y as Viewport,
  p as VirtualPixelMethod,
  W as VirtualViewportProxy,
  Kt as applyAffineMatrix,
  ee as applyPerspectiveMatrix,
  xt as blendColors,
  Qt as createDeferred,
  ut as degreesToRadians,
  He as distort,
  _e as distortUnwrap,
  Yt as gaussJordanElimination,
  dt as invertAffineMatrix,
  ft as invertPerspectiveMatrix,
  mt as isBestFitReversePixelMapper,
  Rt as isColor,
  Vt as isColorResampler,
  Ut as isEwaColorResampler,
  he as isEwaReversePixelMapper,
  Gt as isHasAverageColor,
  Wt as isHasBackgroundColor,
  Ce as isImageAdapter,
  Ht as isPixelAccessor,
  _t as isPixelAccessorWithDimensions,
  Ct as isPoint,
  Le as isResampleFilter,
  Se as isResampleFilterPreset,
  nt as isReversePixelMapper,
  j as isViewportLiteral,
  qt as isVirtualViewportPixelAccessor,
  O as makeCanvas,
  st as perceptibleReciprocal,
  jt as preloadHtmlImage,
  Pt as serviceContainer,
  Ge as toHTMLCanvasElement
};
//# sourceMappingURL=lens.js.map
